{"version":3,"sources":["core/endpoints/publish.js"],"names":["getOperation","validateParams","usePost","getURL","postURL","getRequestTimeout","isAuthSupported","postPayload","prepareParams","handleResponse","prepareMessagePayload","modules","messagePayload","crypto","config","stringifiedPayload","JSON","stringify","cipherKey","encrypt","PNPublishOperation","incomingParams","message","channel","subscribeKey","sendByPost","publishKey","encodeString","getTransactionTimeout","meta","replicate","storeInHistory","ttl","params","store","norep","serverResponse","timetoken"],"mappings":"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","file":"publish.js","sourcesContent":["/* @flow */\n\nimport { PublishResponse, PublishArguments, ModulesInject } from '../flow_interfaces';\nimport operationConstants from '../constants/operations';\nimport utils from '../utils';\n\nfunction prepareMessagePayload(modules, messagePayload) {\n  const { crypto, config } = modules;\n  let stringifiedPayload = JSON.stringify(messagePayload);\n\n  if (config.cipherKey) {\n    stringifiedPayload = crypto.encrypt(stringifiedPayload);\n    stringifiedPayload = JSON.stringify(stringifiedPayload);\n  }\n\n  return stringifiedPayload;\n}\n\nexport function getOperation(): string {\n  return operationConstants.PNPublishOperation;\n}\n\nexport function validateParams({ config }: ModulesInject, incomingParams: PublishArguments) {\n  let { message, channel } = incomingParams;\n\n  if (!channel) return 'Missing Channel';\n  if (!message) return 'Missing Message';\n  if (!config.subscribeKey) return 'Missing Subscribe Key';\n}\n\nexport function usePost(modules: ModulesInject, incomingParams: PublishArguments) {\n  let { sendByPost = false } = incomingParams;\n  return sendByPost;\n}\n\nexport function getURL(modules: ModulesInject, incomingParams: PublishArguments): string {\n  const { config } = modules;\n  const { channel, message } = incomingParams;\n  let stringifiedPayload = prepareMessagePayload(modules, message);\n  return `/publish/${config.publishKey}/${config.subscribeKey}/0/${utils.encodeString(channel)}/0/${utils.encodeString(stringifiedPayload)}`;\n}\n\nexport function postURL(modules: ModulesInject, incomingParams: PublishArguments): string {\n  const { config } = modules;\n  const { channel } = incomingParams;\n  return `/publish/${config.publishKey}/${config.subscribeKey}/0/${utils.encodeString(channel)}/0`;\n}\n\nexport function getRequestTimeout({ config }: ModulesInject) {\n  return config.getTransactionTimeout();\n}\n\nexport function isAuthSupported() {\n  return true;\n}\n\nexport function postPayload(modules: ModulesInject, incomingParams: PublishArguments): string {\n  const { message } = incomingParams;\n  return prepareMessagePayload(modules, message);\n}\n\nexport function prepareParams(modules: ModulesInject, incomingParams: PublishArguments): Object {\n  const { meta, replicate = true, storeInHistory, ttl } = incomingParams;\n  const params = {};\n\n  if (storeInHistory != null) {\n    if (storeInHistory) {\n      params.store = '1';\n    } else {\n      params.store = '0';\n    }\n  }\n\n  if (ttl) {\n    params.ttl = ttl;\n  }\n\n  if (replicate === false) {\n    params.norep = 'true';\n  }\n\n  if (meta && typeof meta === 'object') {\n    params.meta = JSON.stringify(meta);\n  }\n\n  return params;\n}\n\nexport function handleResponse(modules: ModulesInject, serverResponse: Object): PublishResponse {\n  return { timetoken: serverResponse[2] };\n}\n"]}