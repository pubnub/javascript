{"version":3,"sources":["core/endpoints/publish.js"],"names":["prepareMessagePayload","modules","messagePayload","crypto","config","stringifiedPayload","JSON","stringify","cipherKey","encrypt","getOperation","operationConstants","PNPublishOperation","validateParams","incomingParams","message","channel","subscribeKey","usePost","sendByPost","getURL","publishKey","utils","encodeString","postURL","getRequestTimeout","getTransactionTimeout","isAuthSupported","postPayload","prepareParams","meta","replicate","storeInHistory","ttl","params","store","norep","handleResponse","serverResponse","timetoken"],"mappings":"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","sourcesContent":["/* @flow */\n\nimport { PublishResponse, PublishArguments, ModulesInject } from '../flow_interfaces';\nimport operationConstants from '../constants/operations';\nimport utils from '../utils';\n\nfunction prepareMessagePayload(modules, messagePayload) {\n  const { crypto, config } = modules;\n  let stringifiedPayload = JSON.stringify(messagePayload);\n\n  if (config.cipherKey) {\n    stringifiedPayload = crypto.encrypt(stringifiedPayload);\n    stringifiedPayload = JSON.stringify(stringifiedPayload);\n  }\n\n  return stringifiedPayload;\n}\n\nexport function getOperation(): string {\n  return operationConstants.PNPublishOperation;\n}\n\nexport function validateParams({ config }: ModulesInject, incomingParams: PublishArguments) {\n  let { message, channel } = incomingParams;\n\n  if (!channel) return 'Missing Channel';\n  if (!message) return 'Missing Message';\n  if (!config.subscribeKey) return 'Missing Subscribe Key';\n}\n\nexport function usePost(modules: ModulesInject, incomingParams: PublishArguments) {\n  let { sendByPost = false } = incomingParams;\n  return sendByPost;\n}\n\nexport function getURL(modules: ModulesInject, incomingParams: PublishArguments): string {\n  const { config } = modules;\n  const { channel, message } = incomingParams;\n  let stringifiedPayload = prepareMessagePayload(modules, message);\n  return `/publish/${config.publishKey}/${config.subscribeKey}/0/${utils.encodeString(channel)}/0/${utils.encodeString(stringifiedPayload)}`;\n}\n\nexport function postURL(modules: ModulesInject, incomingParams: PublishArguments): string {\n  const { config } = modules;\n  const { channel } = incomingParams;\n  return `/publish/${config.publishKey}/${config.subscribeKey}/0/${utils.encodeString(channel)}/0`;\n}\n\nexport function getRequestTimeout({ config }: ModulesInject) {\n  return config.getTransactionTimeout();\n}\n\nexport function isAuthSupported() {\n  return true;\n}\n\nexport function postPayload(modules: ModulesInject, incomingParams: PublishArguments): string {\n  const { message } = incomingParams;\n  return prepareMessagePayload(modules, message);\n}\n\nexport function prepareParams(modules: ModulesInject, incomingParams: PublishArguments): Object {\n  const { meta, replicate = true, storeInHistory, ttl } = incomingParams;\n  const params = {};\n\n  if (storeInHistory != null) {\n    if (storeInHistory) {\n      params.store = '1';\n    } else {\n      params.store = '0';\n    }\n  }\n\n  if (ttl) {\n    params.ttl = ttl;\n  }\n\n  if (replicate === false) {\n    params.norep = 'true';\n  }\n\n  if (meta && typeof meta === 'object') {\n    params.meta = JSON.stringify(meta);\n  }\n\n  return params;\n}\n\nexport function handleResponse(modules: ModulesInject, serverResponse: Object): PublishResponse {\n  return { timetoken: serverResponse[2] };\n}\n"],"file":"publish.js"}